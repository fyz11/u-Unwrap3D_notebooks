
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Step 0: Segmenting a single cell from a volume image &#8212; u-Unwrap3D Analysis Notebooks</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '03_basic_workflow/Step0_find_cell_surface_from_segmentation';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Step 1: Find and create a genus-0 reference surface, \(S_{ref}(x,y,z)\)" href="Step1_find_reference_surface.html" />
    <link rel="prev" title="Standard workflow for unwrapping 3D surfaces" href="readme.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">u-Unwrap3D Analysis Notebooks</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    u-Unwrap3D Analysis Notebooks
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01_introduction/readme.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_installation/readme.html">Installation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Standard Workflow</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="readme.html">Standard workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Step 0: Segmenting a single cell from a volume image</a></li>
<li class="toctree-l1"><a class="reference internal" href="Step1_find_reference_surface.html">Step 1: Find and create a genus-0 reference surface, <span class="math notranslate nohighlight">\(S_{ref}(x,y,z)\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="Step2_quasiconformal_spherical_parameterization.html">Step 2: Quasi-conformal spherical parameterization of the genus-0 reference surface, <span class="math notranslate nohighlight">\(S_{ref}(x,y,z)\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="Step3_equiareal_spherical_parameterization.html">Step 3: Quasi-equiareal spherical parameterization of a genus-0 surface, <span class="math notranslate nohighlight">\(S_{\text{ref}}(x,y,z)\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="Step4_uv_mapping_spherical_parameterization.html">Step 4: UV mapping <span class="math notranslate nohighlight">\(S_{ref}(x,y,z)\)</span> into 2D using its spherical parameterization, <span class="math notranslate nohighlight">\(S_{\text{ref}}^{\Omega}(x,y,z)\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="Step5_building_topography_surface.html">Step 5: Building the topographic <span class="math notranslate nohighlight">\((d,u,v)\)</span> space of <span class="math notranslate nohighlight">\(S_{ref}(x,y,z)\)</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="Step6_find_topographic_surface_mesh.html">Step 6: Compute topographic surface <span class="math notranslate nohighlight">\(S(d,u,v)\)</span> from topographic binary segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Step7_topographic_cMCF_to_flatten.html">Step 7: Flattening the topographic surface <span class="math notranslate nohighlight">\(S(d,u,v)\)</span> onto the 2D plane</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="full_example_cells/readme.html">Full examples of standard workflow</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="full_example_cells/unwrap_bleb_cell.html">Example 1: Cell with blebs</a></li>
<li class="toctree-l2"><a class="reference internal" href="full_example_cells/unwrap_filopodia_cell.html">Example 3: Cell with filopodia</a></li>
<li class="toctree-l2"><a class="reference internal" href="full_example_cells/unwrap_lamellipodia_cell.html">Example 2: Cell with lamellipodia</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Customizing the standard workflow to input data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../04_customizing_basic_workflow/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">In-depth Breakdown of Mapping Steps</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../05_obtaining_surfaces/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_find_reference_surface/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_uv_parameterization/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_building_topography_space/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_spherical_parameterization/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_flatten_topography_surface/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Transporting measurements between representations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../22_transporting_measurements/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Applying u-Unwrap3D to live-cell imaging</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../16_shape_registration/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_compute_distortion_corrected_uv_measurements/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_surface_flow_analytics/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_tracking_in_uv/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_tracking_analytics/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Applications of different surface representations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../13_segmenting_surface_protrusions/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_volumizing_reference_and_protrusions/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_spherical_harmonics/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mapping open 3D surfaces into 2D</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../12_unwrapping_individual_protrusions/readme.html">Basic workflow for unwrapping 3D surfaces</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01_introduction/glossary.html">Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/fyz11/u-Unwrap3D_notebooks" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/fyz11/u-Unwrap3D_notebooks/issues/new?title=Issue%20on%20page%20%2F03_basic_workflow/Step0_find_cell_surface_from_segmentation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/03_basic_workflow/Step0_find_cell_surface_from_segmentation.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Step 0: Segmenting a single cell from a volume image</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-binary-segmentation-using-otsu-thresholding">1. Basic binary segmentation using Otsu thresholding</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#surface-meshing-the-binary-segmentation">2. Surface meshing the binary segmentation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#measuring-the-mean-curvature-of-the-surface-h-s-x-y-z-and-coloring-on-the-surface-mesh">3. Measuring the mean curvature of the surface, <span class="math notranslate nohighlight">\((H(S(x,y,z)))\)</span> and coloring on the surface mesh</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#map-surface-proximal-membrane-signals-by-traversing-along-the-gradient-of-a-distance-transform-into-the-cell">4. Map surface proximal membrane signals by traversing along the gradient of a distance transform into the cell</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="step-0-segmenting-a-single-cell-from-a-volume-image">
<h1>Step 0: Segmenting a single cell from a volume image<a class="headerlink" href="#step-0-segmenting-a-single-cell-from-a-volume-image" title="Link to this heading">#</a></h1>
<p>In order to remap a cell surface in u-Unwrap3D, the cell must be first segmented from the volumetric image to obtain a binary image. A surface mesh is then created from the binary image typically using the marching cubes algorithm.</p>
<p>This workbook walks through this process.</p>
<p><strong>N.B:</strong> We illustrate the most basic way to segment a cell using an automatic binary thresholding method. This fundamentally assumes you have high signal-to-noise ratio image where the single cell is very well delineated from the background. Moreover it assumes the illumination is uniform and the cell is bright. Thus it is not generally applicable. If you have a better 3D segmentation method, please use that and only follow to see how to extract a surface mesh.</p>
<p><strong>Warning concerning segmentation</strong>:
In order to ensure the extracted mesh truly captures the surface, it is crucial to check in this step that the binary image is indeed capturing the whole cell such that the interior cell volume is ‘filled’. An easy check is to visualize a mid-section slice of the binary, and check the interior all has the equivalent of a binary 1. If this is not true, the cell will be ‘double-meshed’ and the extracted ‘surface’ actually represents the exterior shell. Whilst u-Unwrap3D can handle these imperfect surface meshes, they do affect quantification e.g. you will measure approximately twice larger surface area, and a very small cell volume.</p>
<section id="basic-binary-segmentation-using-otsu-thresholding">
<h2>1. Basic binary segmentation using Otsu thresholding<a class="headerlink" href="#basic-binary-segmentation-using-otsu-thresholding" title="Link to this heading">#</a></h2>
<p>We read in the volume image used in Fig.1 of the u-Unwrap3D paper and also create a savefolder to store the results of analysis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">skimage.io</span> <span class="k">as</span> <span class="nn">skio</span> 
<span class="kn">import</span> <span class="nn">os</span> 
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">pylab</span> <span class="k">as</span> <span class="nn">plt</span> 

<span class="kn">import</span> <span class="nn">unwrap3D.Visualisation.volume_img</span> <span class="k">as</span> <span class="nn">vol_img_viz</span> <span class="c1"># for creating a montage maximum projection</span>
<span class="kn">import</span> <span class="nn">unwrap3D.Utility_Functions.file_io</span> <span class="k">as</span> <span class="nn">fio</span> <span class="c1"># for common IO functions</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Specifying image file location and parsing its name. </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">imgfolder</span> <span class="o">=</span> <span class="s1">&#39;../../data/img&#39;</span>
<span class="n">imgfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">imgfolder</span><span class="p">,</span> <span class="s1">&#39;bleb_example.tif&#39;</span><span class="p">)</span>

<span class="n">basefname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">imgfile</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># get the filename with extension</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Initialise a save folder to store the important outputs for the result of the pipeline.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">savefolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;example_results&#39;</span><span class="p">,</span> 
                         <span class="n">basefname</span><span class="p">,</span>
                         <span class="s1">&#39;step0_cell_segmentation&#39;</span><span class="p">)</span>
<span class="n">fio</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">savefolder</span><span class="p">)</span> <span class="c1"># auto generates the specified folder structure if doesn&#39;t currently exist.</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Read and display image</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># read the image using scikit-image</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">skio</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">imgfile</span><span class="p">)</span>

<span class="c1"># utility function in u-Unwrap3D to generate a montage maximum projection of the 3 orthogonal views for display</span>
<span class="n">img_proj</span> <span class="o">=</span> <span class="n">vol_img_viz</span><span class="o">.</span><span class="n">montage_vol_proj</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>


<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Montage maximum projection&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_proj</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savefolder</span><span class="p">,</span>
                        <span class="n">basefname</span><span class="o">+</span><span class="s1">&#39;_max-proj_three.png&#39;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/72ef2458c3f13850a3329cb81942bf99038d137a55321fa95c02265280703c18.png" src="../_images/72ef2458c3f13850a3329cb81942bf99038d137a55321fa95c02265280703c18.png" />
</div>
</div>
<p>The image contains a single cell. The whole of the cell is brighter than the background. Moreover the signal-to-noise (SNR) ratio is excellent, with the cell well-delineated from the background. In this case, we can segment the single cell with an intensity threshold automatically determined by <a class="reference external" href="https://en.wikipedia.org/wiki/Otsu%27s_method">Otsu’s method</a> from the scikit-image library (<a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.filters.html#skimage.filters.threshold_otsu">skimage.filters.threshold_otsu</a>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unwrap3D.Segmentation.segmentation</span> <span class="k">as</span> <span class="nn">segmentation</span> <span class="c1"># import the segmentation submodule which wraps the Otsu method</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span> <span class="k">as</span> <span class="nn">ndimage</span> <span class="c1"># use instead of scikit-image for faster morphological operations in 3D</span>
<span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">skmorph</span>

<span class="c1"># returns the binary and the auto determined threshold. </span>
<span class="n">img_binary</span><span class="p">,</span> <span class="n">img_binary_thresh</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">segment_vol_thresh</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="c1"># erode by ball kernel radius = 1 to make a tighter binary</span>
<span class="n">img_binary</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">img_binary</span><span class="p">,</span> 
                                    <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                                    <span class="n">structure</span><span class="o">=</span><span class="n">skmorph</span><span class="o">.</span><span class="n">ball</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">img_binary_proj</span> <span class="o">=</span> <span class="n">vol_img_viz</span><span class="o">.</span><span class="n">montage_vol_proj</span><span class="p">(</span><span class="n">img_binary</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Montage binary segmentation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_binary_proj</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savefolder</span><span class="p">,</span>
                         <span class="n">basefname</span><span class="o">+</span><span class="s1">&#39;_binary_three.png&#39;</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Save the binary out as a uint8 .tif</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">skio</span><span class="o">.</span><span class="n">imsave</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savefolder</span><span class="p">,</span>
                         <span class="n">basefname</span><span class="o">+</span><span class="s1">&#39;_binary_seg.tif&#39;</span><span class="p">),</span> 
            <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">img_binary</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/cf8f87021d6d8b9e55f6fcfa1a78035621321ea04af9f61b98d796e46c44fade.png" src="../_images/cf8f87021d6d8b9e55f6fcfa1a78035621321ea04af9f61b98d796e46c44fade.png" />
</div>
</div>
<p>We see from the cross-section visualization of x-y, x-z and y-z views, that the segmentation captures the full cell, with the cell interior filled in (i.e. all white pixels). Therefore we move ahead to extract its surface using marching cubes.</p>
</section>
<section id="surface-meshing-the-binary-segmentation">
<h2>2. Surface meshing the binary segmentation<a class="headerlink" href="#surface-meshing-the-binary-segmentation" title="Link to this heading">#</a></h2>
<p>We mesh the binary segmentation (0 or 1 value) using marching cubes at an isovalue of 0.5. The triangles obtained from this are very heterogeneous. Ideally, in mesh analysis, triangles should be close to regular and equilateral. This is particularly important for later steps where we need to solve differential equations on the mesh. Therefore we apply remeshing on the marching cubes output.</p>
<p>u-Unwrap3D provides two isotropic remeshing algorithms: 1) <a class="reference external" href="https://github.com/pyvista/pyacvd">pyacvd</a> which uses voronoi clustering or 2) the incremental method of Botsch in <a class="reference external" href="https://doc.cgal.org/latest/Polygon_mesh_processing/index.html">CGAL</a> based on splitting long edge lengths and collapsing short ones to obtain uniform triangles of a desired length.</p>
<p>We developed u-Unwrap3D initially using method 1 which does not work without requesting an output mesh with fewer vertices (typically at least &lt; 0.5x starting number of vertices). We have since found that the Botsch method is more robust, computable for output mesh with more, same and less vertices, and it better preserves ‘sharp’ high curvature features. This is now our recommended method, and is used here.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unwrap3D.Mesh.meshtools</span> <span class="k">as</span> <span class="nn">meshtools</span> <span class="c1"># load in the meshtools submodule</span>

<span class="n">img_binary_surf_mesh</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">marching_cubes_mesh_binary</span><span class="p">(</span><span class="n">img_binary</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="c1"># The transpose is to be consistent with ImageJ rendering and Matlab convention  </span>
                                                                <span class="n">presmooth</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="c1"># applies a presmooth</span>
                                                                <span class="n">contourlevel</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span>
                                                                <span class="n">remesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                <span class="n">remesh_method</span><span class="o">=</span><span class="s1">&#39;CGAL&#39;</span><span class="p">,</span> <span class="c1"># &#39;pyacvd&#39; = method 1, &#39;CGAL&#39; = method 2</span>
                                                                <span class="n">remesh_samples</span><span class="o">=</span><span class="mf">.5</span><span class="p">,</span> <span class="c1"># remeshing with a target #vertices. 0.5 = 50% of original vertex number</span>
                                                                <span class="n">predecimate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># this applies quadric mesh simplication to remove very small edges before remeshing. This must be True if using method 1, &#39;pyacvd&#39;</span>
                                                                <span class="n">min_mesh_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="c1"># enforce at least this number of vertices.</span>
                                                                <span class="n">upsamplemethod</span><span class="o">=</span><span class="s1">&#39;inplane&#39;</span><span class="p">)</span> <span class="c1"># upsample the mesh if after the simplification and remeshing &lt; min_mesh_size  </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A quick way to check the genus is to get the euler number. The genus of the mesh is related to the euler number by</span>
<span class="sd">A genus-0 mesh should have euler number = 2</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Euler characteristic of mesh is: &#39;</span><span class="p">,</span> <span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">euler_number</span><span class="p">)</span> <span class="c1">#should be 2 if genus is 0</span>

<span class="c1"># we also provide a more comprehensive function for common mesh properties</span>
<span class="n">mesh_property</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">measure_props_trimesh</span><span class="p">(</span><span class="n">img_binary_surf_mesh</span><span class="p">,</span> <span class="n">main_component</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">mesh_property</span><span class="p">)</span> <span class="c1"># note: if we have a proper surface mesh, &#39;volume&#39;=True, Technically the mesh should also be &#39;watertight&#39; but this is too strict a condition and often doesn&#39;t hold true for meshes of complex cell surface morphologies obtained from cell segmentation.</span>

<span class="c1"># we also provide a function to check triangle quality. </span>
<span class="n">triangle_property</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">measure_triangle_props</span><span class="p">(</span><span class="n">img_binary_surf_mesh</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">triangle_property</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Euler characteristic of mesh is:  2
{&#39;convex&#39;: False, &#39;volume&#39;: True, &#39;watertight&#39;: True, &#39;orientability&#39;: True, &#39;euler_number&#39;: 2, &#39;genus&#39;: 0.0}
{&#39;min_angle&#39;: 31.001835560609603, &#39;avg_angle&#39;: 60.000000000000014, &#39;max_angle&#39;: 104.81219458015215, &#39;std_dev_angle&#39;: 8.923689441212806, &#39;min_quality&#39;: 0.654771104193233, &#39;avg_quality&#39;: 0.965323078564477, &#39;max_quality&#39;: 0.9999994081997989, &#39;quality&#39;: array([0.9766652 , 0.95054543, 0.96960764, ..., 0.73999298, 0.82937982,
       0.83884083]), &#39;angles&#39;: array([[1.05132536, 0.89254217, 1.19772513],
       [0.80075156, 1.20338585, 1.13745524],
       [0.91410565, 1.25104304, 0.97644396],
       ...,
       [1.70714756, 0.75943757, 0.67500753],
       [1.56349544, 0.74061199, 0.83748522],
       [1.53577656, 0.71951787, 0.88629823]])}
</pre></div>
</div>
</div>
</div>
</section>
<section id="measuring-the-mean-curvature-of-the-surface-h-s-x-y-z-and-coloring-on-the-surface-mesh">
<h2>3. Measuring the mean curvature of the surface, <span class="math notranslate nohighlight">\((H(S(x,y,z)))\)</span> and coloring on the surface mesh<a class="headerlink" href="#measuring-the-mean-curvature-of-the-surface-h-s-x-y-z-and-coloring-on-the-surface-mesh" title="Link to this heading">#</a></h2>
<p>There are many ways to determine the mean curvature of the surface with different pros and cons.</p>
<ol class="arabic simple">
<li><p><strong>From surface mesh</strong></p></li>
</ol>
<p>Measuring surface mean curvature typically involves fitting a local plane to neighborhood vertices of a surface mesh. see: <code class="docutils literal notranslate"><span class="pre">unwrap3D.Mesh.meshtools.compute_mean_curvature</span></code>. If the surface mesh has topological errors, e.g. containing holes, this measurement is not accurate. It can also be subject to the quality of the triangle faces and choice of neighborhood radius.</p>
<ol class="arabic simple" start="2">
<li><p><strong>From binary segmentation</strong></p></li>
</ol>
<p>We find it easier and more accurate for downstream quantification to measure curvature from the continuous definition of mean curvature, <span class="math notranslate nohighlight">\(H\)</span> using the binary segmentation whereby we can easily apply morphological operations like dilation and hole-filling to fix small mesh errors.</p>
<div class="math notranslate nohighlight">
\[ H = {-\frac{1}{2} \nabla \cdot \hat{n}} \]</div>
<p>where <span class="math notranslate nohighlight">\(\hat{n}\)</span> is the unit surface normal vector, and also the gradient of the signed distance function <span class="math notranslate nohighlight">\(\Phi\)</span> of the binary segmentation.</p>
<div class="math notranslate nohighlight">
\[ \hat{n} = {\nabla \Phi} \]</div>
<p>The curvature at the surface is then obtained by interpolating at the surface mesh vertices.</p>
<p>This is however typically slower.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unwrap3D.Mesh.meshtools</span> <span class="k">as</span> <span class="nn">meshtools</span>

<span class="c1"># compute the continuous mean curvature definition and smooth slightly with a Gaussian of sigma=3.  </span>
<span class="n">surf_H</span><span class="p">,</span> <span class="p">(</span><span class="n">H_binary</span><span class="p">,</span> <span class="n">H_sdf_vol_normal</span><span class="p">,</span> <span class="n">H_sdf_vol</span><span class="p">)</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">compute_mean_curvature_from_binary</span><span class="p">(</span><span class="n">img_binary_surf_mesh</span><span class="p">,</span> 
                                                                                    <span class="n">img_binary</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> 
                                                                                    <span class="n">smooth_gradient</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="c1"># adjusts smoothing, plays similar role to neighborhood radius in mesh method</span>
                                                                                    <span class="n">eps</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span>
                                                                                    <span class="n">invert_H</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># set True if you want positive values to correspond to positive curvature on the surface like blebs and binary is not transposed, otherwise set False. </span>
                                                                                    <span class="n">return_H_img</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># set return_H_img to be True, if </span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">131</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">H_binary</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral_r&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">132</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">H_binary</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral_r&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">133</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">H_binary</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral_r&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">);</span> <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/4139dc314f45bbf6ae80967ff3151000585c13c41ce2c22a03929616522d9122.png" src="../_images/4139dc314f45bbf6ae80967ff3151000585c13c41ce2c22a03929616522d9122.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unwrap3D.Image_Functions.image</span> <span class="k">as</span> <span class="nn">image_fn</span> <span class="c1"># for common image processing functions</span>
<span class="kn">import</span> <span class="nn">unwrap3D.Visualisation.colors</span> <span class="k">as</span> <span class="nn">vol_colors</span> <span class="c1"># this is for colormapping any np.array using a color palette </span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span> <span class="c1"># this is for specifying a matplotlib color palette</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">We map the curvature values to a colorscheme for display. To set the scale, we use the voxel size to convert to metric units of $\mu m^{-1}$</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># we generate colors from the mean curvature </span>
<span class="n">voxel_size</span> <span class="o">=</span> <span class="mf">0.104</span> <span class="c1">#um</span>
<span class="n">surf_H_colors</span> <span class="o">=</span> <span class="n">vol_colors</span><span class="o">.</span><span class="n">get_colors</span><span class="p">(</span><span class="n">surf_H</span><span class="o">/</span><span class="n">voxel_size</span><span class="p">,</span> <span class="c1"># 0.104 is the voxel resolution -&gt; this converts to um^-1 </span>
                                      <span class="n">colormap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">Spectral_r</span><span class="p">,</span> 
                                      <span class="n">vmin</span><span class="o">=-</span><span class="mf">1.</span><span class="p">,</span> 
                                      <span class="n">vmax</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> <span class="c1"># colormap H with lower and upper limit of -1, 1 um^-1. </span>

<span class="c1"># set the vertex colors to the computed mean curvature color</span>
<span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">vertex_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">surf_H_colors</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span> 

<span class="c1"># save the mesh for viewing in an external program such as meshlab which offers much better rendering capabilities</span>
<span class="n">tmp</span> <span class="o">=</span> <span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savefolder</span><span class="p">,</span> <span class="s1">&#39;curvature_binary_mesh_&#39;</span><span class="o">+</span><span class="n">basefname</span><span class="o">+</span><span class="s1">&#39;.obj&#39;</span><span class="p">))</span> <span class="c1"># tmp is used to prevent printing to screen.</span>
</pre></div>
</div>
</div>
</div>
<p>The saved surface mesh is in .obj format. These are best viewed in a dedicated mesh viewer such as <a class="reference external" href="https://www.meshlab.net/">meshlab</a>, or <a class="reference external" href="https://github.com/RBVI/ChimeraX">chimerax</a> which are opensource, free and cross-platform.</p>
<p>Within python, we can get an idea without installing more specialized libraries such as <a class="reference external" href="https://vedo.embl.es/">vedo</a> by 3D scatter plotting and coloring the mesh vertices with matplotlib.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">unwrap3D.Visualisation.plotting</span> <span class="k">as</span> <span class="nn">plotting</span> <span class="c1"># we import this so we can make x,y,z axes be plotted in equal proportions. </span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> 
           <span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
           <span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
           <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
           <span class="n">c</span><span class="o">=</span><span class="n">surf_H</span><span class="o">/</span><span class="n">voxel_size</span><span class="p">,</span> 
           <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Spectral_r&#39;</span><span class="p">,</span> 
           <span class="n">vmin</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
           <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">set_axes_equal</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ec67222a719cf6e9129e84e28686c77b18e63dafd0a6998c56f562c507c95c8d.png" src="../_images/ec67222a719cf6e9129e84e28686c77b18e63dafd0a6998c56f562c507c95c8d.png" />
</div>
</div>
</section>
<section id="map-surface-proximal-membrane-signals-by-traversing-along-the-gradient-of-a-distance-transform-into-the-cell">
<h2>4. Map surface proximal membrane signals by traversing along the gradient of a distance transform into the cell<a class="headerlink" href="#map-surface-proximal-membrane-signals-by-traversing-along-the-gradient-of-a-distance-transform-into-the-cell" title="Link to this heading">#</a></h2>
<p>We can use active contour conformalized mean curvature flow, (see the u-Unwrap3D <a class="reference external" href="https://www.biorxiv.org/content/10.1101/2023.04.12.536640v2">paper</a>) to traverse into the cell and sample the image intensity at designed step sizes <span class="math notranslate nohighlight">\(\alpha\)</span> along the gradient of a signed distance function. We can then average the sampled intensity and map this onto the cell surface. We do this for our cell up to 1 <span class="math notranslate nohighlight">\(\mu m\)</span> depth. Our image has an isotropic voxel resolution of 0.104 <span class="math notranslate nohighlight">\(\mu m\)</span>. We sample this depth in steps of 0.5 voxels. This equates to a total of 1./(0.104*0.5) steps rounded down to the nearest integer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n_samples</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span> <span class="n">voxel_size</span> <span class="c1"># total number of steps</span>
<span class="n">stepsize</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># voxels</span>
    
<span class="c1"># flip the mesh vertex coordinates so that it aligns with the volume size </span>
<span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># run the active contour cMCF to get the coordinates at different depths into the cell according to the external image gradient given by the gradient of the signed distance function.</span>
<span class="n">v_depth</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">parametric_mesh_constant_img_flow</span><span class="p">(</span><span class="n">img_binary_surf_mesh</span><span class="p">,</span> 
                                                      <span class="n">external_img_gradient</span> <span class="o">=</span> <span class="n">H_sdf_vol_normal</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> 
                                                      <span class="n">niters</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">n_samples</span><span class="o">/</span><span class="n">stepsize</span><span class="p">),</span> 
                                                      <span class="n">deltaL</span><span class="o">=</span><span class="mf">5e-5</span><span class="p">,</span> <span class="c1"># delta which controls the stiffness of the mesh</span>
                                                      <span class="n">step_size</span><span class="o">=</span><span class="n">stepsize</span><span class="p">,</span> 
                                                      <span class="n">method</span><span class="o">=</span><span class="s1">&#39;implicit&#39;</span><span class="p">,</span> <span class="c1"># this specifies the cMCF solver.</span>
                                                      <span class="n">conformalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># ensure we use the cMCF Laplacian</span>

<span class="c1"># we can check the size of the array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v_depth</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># we can plot the trajectory with matplotlib </span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100%|██████████| 19/19 [00:05&lt;00:00,  3.70it/s]
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(23745, 3, 20)
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<p><strong>Implementation Warning Note:</strong></p>
<p>We typically use the signed distance function given by the Euclidean distance transform (EDT) as illustrated above to deform the mesh and sample the intensities, as it is fast to compute and memory-efficient. However, when sampling thin, narrow, and long protrusions. The result of the EDT will look ‘blocky’. In these cases, it is more optimal to compute the signed distance function given by solving the Poisson equation (see: <code class="docutils literal notranslate"><span class="pre">unwrap3D.Segmentation.segmentation.poisson_dist_tform_3D</span></code>). However, our current implementation uses an exact LU solver which is slow and will likely memory error. We recommend computing the distance transform on the isotropically downsampled binary segmentation (e.g. 1/8th), then resizing the result to the original size. This is valid because the distance transform is smooth.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get the intensities at the sampled depth coordinates. </span>
<span class="n">v_depth_I</span> <span class="o">=</span> <span class="n">image_fn</span><span class="o">.</span><span class="n">map_intensity_interp3</span><span class="p">(</span><span class="n">v_depth</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> 
                                            <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> 
                                            <span class="n">I_ref</span><span class="o">=</span><span class="n">img</span><span class="p">)</span>
<span class="n">v_depth_I</span> <span class="o">=</span> <span class="n">v_depth_I</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">v_depth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># matrix reshaping into a nicer shape. </span>

<span class="c1"># postprocess to check the total distance from the surface does not exceed the desired and replace any nans.  </span>
<span class="n">dist_v_depth0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v_depth</span> <span class="o">-</span> <span class="n">v_depth</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">valid_I</span> <span class="o">=</span> <span class="n">dist_v_depth0</span><span class="o">&lt;=</span><span class="n">n_samples</span>
<span class="n">v_depth_I</span><span class="p">[</span><span class="n">valid_I</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># replace with nans</span>


<span class="c1"># compute the mean sampled intensity which will be taken as the surface intensity. </span>
<span class="n">surf_intensity_img_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">v_depth_I</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">surf_intensity_img_raw</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">surf_intensity_img_raw</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># for visualization, we find the intensity range to be more pleasing if clipped to between the 1st and 99th percentile. </span>
<span class="n">I_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">surf_intensity_img_raw</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">I_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">surf_intensity_img_raw</span><span class="p">,</span><span class="mi">99</span><span class="p">)</span>

<span class="n">surf_intensity_img_raw_colors</span> <span class="o">=</span> <span class="n">vol_colors</span><span class="o">.</span><span class="n">get_colors</span><span class="p">(</span><span class="n">surf_intensity_img_raw</span><span class="p">,</span> 
                                                      <span class="n">colormap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">RdYlBu_r</span><span class="p">,</span>   
                                                      <span class="n">vmin</span><span class="o">=</span><span class="n">I_min</span><span class="p">,</span> 
                                                      <span class="n">vmax</span><span class="o">=</span><span class="n">I_max</span><span class="p">)</span>
<span class="c1"># create a new surface mesh, now with the PI3K molecular signal colors. </span>
<span class="n">img_binary_surf_mesh_colors</span> <span class="o">=</span> <span class="n">meshtools</span><span class="o">.</span><span class="n">create_mesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="n">faces</span><span class="o">=</span><span class="n">img_binary_surf_mesh</span><span class="o">.</span><span class="n">faces</span><span class="p">,</span> 
                                                  <span class="n">vertex_colors</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span><span class="o">*</span><span class="n">surf_intensity_img_raw_colors</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">]))</span> 
<span class="n">tmp</span> <span class="o">=</span> <span class="n">img_binary_surf_mesh_colors</span><span class="o">.</span><span class="n">export</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savefolder</span><span class="p">,</span> 
                                                <span class="s1">&#39;PI3K_binary_mesh_&#39;</span><span class="o">+</span><span class="n">basefname</span><span class="o">+</span><span class="s1">&#39;.obj&#39;</span><span class="p">))</span> <span class="c1"># tmp is used to prevent printing to screen.</span>


<span class="c1"># again we can quickly view the coloring in matplotlib</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">img_binary_surf_mesh_colors</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> 
           <span class="n">img_binary_surf_mesh_colors</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
           <span class="n">img_binary_surf_mesh_colors</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> 
           <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
           <span class="n">c</span><span class="o">=</span><span class="n">surf_intensity_img_raw</span><span class="p">,</span> 
           <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu_r&#39;</span><span class="p">,</span> 
           <span class="n">vmin</span><span class="o">=-</span><span class="n">I_min</span><span class="p">,</span>
           <span class="n">vmax</span><span class="o">=</span><span class="n">I_max</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="o">-</span><span class="mi">60</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
<span class="n">plotting</span><span class="o">.</span><span class="n">set_axes_equal</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># finally we will save the actual numerical values of the surface curvature and intensity to avoid recomputation to use for other steps of the pipeline</span>
<span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="nn">spio</span> <span class="c1"># we save in .mat, this will allow matlab users to use the output if desired</span>
<span class="n">spio</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">savefolder</span><span class="p">,</span> 
                          <span class="n">basefname</span><span class="o">+</span><span class="s1">&#39;_surface_curvature_intensity_stats.mat&#39;</span><span class="p">),</span> 
            <span class="p">{</span><span class="s1">&#39;surf_H&#39;</span><span class="p">:</span> <span class="n">surf_H</span><span class="p">,</span>
             <span class="s1">&#39;surf_intensity&#39;</span> <span class="p">:</span> <span class="n">surf_intensity_img_raw</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/efb5fce9ccfded09ce46194464c04e66e097f8f210750d025a3634f377e0c086.png" src="../_images/efb5fce9ccfded09ce46194464c04e66e097f8f210750d025a3634f377e0c086.png" />
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./03_basic_workflow"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="readme.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Standard workflow for unwrapping 3D surfaces</p>
      </div>
    </a>
    <a class="right-next"
       href="Step1_find_reference_surface.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Step 1: Find and create a genus-0 reference surface, <span class="math notranslate nohighlight">\(S_{ref}(x,y,z)\)</span></p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-binary-segmentation-using-otsu-thresholding">1. Basic binary segmentation using Otsu thresholding</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#surface-meshing-the-binary-segmentation">2. Surface meshing the binary segmentation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#measuring-the-mean-curvature-of-the-surface-h-s-x-y-z-and-coloring-on-the-surface-mesh">3. Measuring the mean curvature of the surface, <span class="math notranslate nohighlight">\((H(S(x,y,z)))\)</span> and coloring on the surface mesh</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#map-surface-proximal-membrane-signals-by-traversing-along-the-gradient-of-a-distance-transform-into-the-cell">4. Map surface proximal membrane signals by traversing along the gradient of a distance transform into the cell</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Felix Y. Zhou
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <p>
Copyright: Licensed <a href="https://github.com/fyz11/u-Unwrap3D_notebooks/blob/main/LICENSE" target="_blank">GPL3</a> unless mentioned otherwise. 
</p>

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>